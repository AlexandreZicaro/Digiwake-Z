#include <LedControl.h>
#include <avr/pgmspace.h>
#include <Wire.h>
#include <RTClib.h>
#include <SPI.h>
#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Broches de raccordement Arduino Nano → Matrice LED pilotée par MAX7219
#define brocheDeSelection 10
#define brochePourLesDonnees 11
#define brochePourLhorloge 13
#define nombreDeMatricesLedRaccordees 4

// Broches pour l'écran OLED et le potentiomètre
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const int potPin = A0;
const int buttonSelectPin = 2;
const int buttonBackPin = 3;
int menuOption = 0;
const int numOptions = 4;
int lastPotValue = 0;
int threshold = 50;

// Variables pour le lissage du potentiomètre
#define NOMBRE_LISSAGE 10  // Nombre de lectures pour lisser la valeur
#define SEUIL_DE_CHANGEMENT 512  // Seuil de changement de format (modifié selon la plage de potentiomètre)
int valeursPotentiometre[NOMBRE_LISSAGE];  // Tableau pour stocker les dernières valeurs
int indice = 0;  // Indice pour ajouter de nouvelles valeurs

// Instanciation des objets LedControl et RTC
LedControl matriceLed = LedControl(brochePourLesDonnees, brochePourLhorloge, brocheDeSelection, nombreDeMatricesLedRaccordees);
RTC_DS3231 rtc;

// Définition des chiffres en PROGMEM
const byte CHIFFRES[10][8] PROGMEM = {
  {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100},
  {0b00001000, 0b00011000, 0b00101000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00011100},
  {0b00111100, 0b01000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000010, 0b01111110},
  {0b00111100, 0b01000010, 0b00000110, 0b00011110, 0b00000110, 0b00000110, 0b01000010, 0b00111100},
  {0b00000100, 0b00001100, 0b00010100, 0b00100100, 0b01111110, 0b00000100, 0b00000100, 0b00000100},
  {0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b00000010, 0b00000010, 0b01000010, 0b00111100},
  {0b00111100, 0b01000010, 0b01000000, 0b01111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100},
  {0b01111110, 0b00000010, 0b00000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000000},
  {0b00111100, 0b01000010, 0b01000010, 0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100},
  {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111110, 0b00000010, 0b01000010, 0b00111100}
};

// Variables globales
bool format24h = true;
bool modeAjustement = false;

// Fonctions de gestion des affichages
void afficherChiffre(int position, const byte* chiffre) {
  for (int i = 0; i < 8; i++) {
    matriceLed.setRow(position, i, pgm_read_byte(&(chiffre[i])));
  }
}

void afficherHeure(int heures, int minutes, bool amPm) {
  afficherChiffre(3, CHIFFRES[heures / 10]);
  afficherChiffre(2, CHIFFRES[heures % 10]);
  afficherChiffre(1, CHIFFRES[minutes / 10]);
  afficherChiffre(0, CHIFFRES[minutes % 10]);

  if (!format24h) {
    matriceLed.setChar(3, 6, amPm ? 'P' : 'A', false);
    matriceLed.setChar(3, 7, 'M', false);
  }
}

// Lissage de la valeur du potentiomètre
int lirePotentiometreStable() {
  int somme = 0;
  // Ajouter la nouvelle valeur dans le tableau
  valeursPotentiometre[indice] = analogRead(potPin);
  indice = (indice + 1) % NOMBRE_LISSAGE;

  // Calculer la moyenne des dernières lectures
  for (int i = 0; i < NOMBRE_LISSAGE; i++) {
    somme += valeursPotentiometre[i];
  }

  return somme / NOMBRE_LISSAGE;  // Retourner la moyenne
}

void displayMenu(int option) {
  display.clearDisplay();
  display.setCursor(0, 0);
  
  const char* menuOptions[] = {"Option 1", "Option 2", "Option 3", "Option 4"};
  
  for (int i = 0; i < numOptions; i++) {
    display.setTextColor(i == option ? BLACK : WHITE, i == option ? WHITE : BLACK);
    display.setCursor(0, i * 10);
    display.println(menuOptions[i]);
  }
  display.display();
}

void selectFormat() {
  delay(1000);
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("select format");
  display.setCursor(0, 10);
  display.println("1. 24h");
  display.setCursor(0, 20);
  display.println("2. 12h AM/PM");
  display.display();

  int lastSubOption = 0;
  bool selecting = true;
  while (selecting) {
    // Lire la valeur stable du potentiomètre
    int potValue = lirePotentiometreStable();
    int subOption = (potValue < SEUIL_DE_CHANGEMENT) ? 1 : 2;  // 1 pour 24h, 2 pour 12h

    // Afficher la sélection de manière lisible si l'option a changé
    if (subOption != lastSubOption) {
      lastSubOption = subOption;

      display.setCursor(0, 10);
      display.setTextColor(subOption == 1 ? BLACK : WHITE, subOption == 1 ? WHITE : BLACK);
      display.println("1. 24h");

      display.setCursor(0, 20);
      display.setTextColor(subOption == 2 ? BLACK : WHITE, subOption == 2 ? WHITE : BLACK);
      display.println("2. 12h AM/PM");
      display.display();

      delay(200);  // Attendre un peu avant de redessiner l'écran
    }

    // Confirmer la sélection avec le bouton sur la broche 2
    if (digitalRead(buttonSelectPin) == LOW) {
      selecting = false;
      format24h = (subOption == 1);  // Définir le format en fonction de l'option sélectionnée
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(format24h ? "Format 24h choisi" : "Format 12h AM/PM choisi");
      display.display();
      delay(2000);  // Attendre 2 secondes pour afficher la confirmation

      // Attendre que le bouton soit relâché
      while (digitalRead(buttonSelectPin) == LOW) {
        delay(10);
      }
    }
  }
}

void selectOption(int option) {
  if (option == 0) {
    selectFormat();
  } else {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Option " + String(option + 1) + " choisie");
    display.display();
    delay(2000);
  }
}

void setup() {
  for (int i = 0; i < nombreDeMatricesLedRaccordees; i++) {
    matriceLed.shutdown(i, false);
    matriceLed.setIntensity(i, 8);
    matriceLed.clearDisplay(i);
  }

  Serial.begin(9600);
  Wire.begin();
  rtc.begin();
  rtc.adjust(DateTime(__DATE__, __TIME__));

  pinMode(buttonSelectPin, INPUT_PULLUP);
  pinMode(buttonBackPin, INPUT_PULLUP);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }

  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  displayMenu(menuOption);
}

void loop() {
  int potValue = analogRead(potPin);

  if (abs(potValue - lastPotValue) > threshold) {
    menuOption = map(potValue, 0, 1023, 0, numOptions - 1); 
    lastPotValue = potValue;
    displayMenu(menuOption);
  }

  if (digitalRead(buttonSelectPin) == LOW) {
    selectOption(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonSelectPin) == LOW) {
      delay(10);
    }
  }

  if (digitalRead(buttonBackPin) == LOW) {
    displayMenu(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonBackPin) == LOW) {
      delay(10);
    }
  }

  if (!modeAjustement) {
    static int minutePrecedente = -1;
    static bool pointAllume = false;
    DateTime now = rtc.now();

    int heures = now.hour();
    int minutes = now.minute();
    bool amPm = heures >= 12;

    if (!format24h) {
      if (heures == 0) heures = 12;
      else if (heures > 12) heures -= 12;
    }

    if (minutes != minutePrecedente) {
      minutePrecedente = minutes;
      afficherHeure(heures, minutes, amPm);
    }

    pointAllume = !pointAllume;
    matriceLed.setLed(2, 3, 7, pointAllume);

    delay(1000);
  }

  // Attendre l'appui sur le bouton de retour pour revenir au menu principal
  if (digitalRead(buttonBackPin) == LOW) {
    displayMenu(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonBackPin) == LOW) {
      delay(10);
    }
  }
}
