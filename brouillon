#include <LedControl.h>
#include <avr/pgmspace.h>
#include <Wire.h>
#include <RTClib.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


// Broches pour l'écran OLED et le potentiomètre
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const int potPin = A0;
const int buttonSelectPin = 2;
const int buttonBackPin = 3;
int menuOption = 0;
const int numOptions = 4;
int lastPotValue = 0;
int threshold = 50;

// Variables pour le lissage du potentiomètre
#define NOMBRE_LISSAGE 10  // Nombre de lectures pour lisser la valeur
#define SEUIL_DE_CHANGEMENT 512  // Seuil de changement de format (modifié selon la plage de potentiomètre)
int valeursPotentiometre[NOMBRE_LISSAGE];  // Tableau pour stocker les dernières valeurs
int indice = 0;  // Indice pour ajouter de nouvelles valeurs
// Définition des broches de raccordement Arduino Nano → Matrice LED pilotée par MAX7219
#define brocheDeSelection               10  // Sortie D10 de l'Arduino (/SS) vers la broche CS de la matrice LED
#define brochePourLesDonnees            11  // Sortie D11 de l'Arduino (MOSI) vers la broche DIN de la matrice LED
#define brochePourLhorloge              13  // Sortie D13 de l'Arduino (SCK) vers la broche CLK de la matrice LED
#define ok              2 
#define boutonHeures   5  // Bouton pour ajuster les heures (D3)
#define boutonMinutes  4  // Bouton pour ajuster les minutes (D4)
#define boutonValider  3  // Bouton pour valider l'heure ajustée (D5)
#define buzzerPin      8  // Buzzer connecté à D8

// Définition des autres constantes
#define nombreDeMatricesLedRaccordees   4   // Nombre total de matrices LED (4 pour HH:MM)

// Instanciation des objets LedControl et RTC
LedControl matriceLed = LedControl(brochePourLesDonnees, brochePourLhorloge, brocheDeSelection, nombreDeMatricesLedRaccordees);
RTC_DS3231 rtc;

// Définition des chiffres en PROGMEM
const byte CHIFFRE_0[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_1[] PROGMEM = {0b00001000, 0b00011000, 0b00101000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00011100};
const byte CHIFFRE_2[] PROGMEM = {0b00111100, 0b01000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000010, 0b01111110};
const byte CHIFFRE_3[] PROGMEM = {0b00111100, 0b01000010, 0b00000110, 0b00011100, 0b00000110, 0b00000010, 0b01000010, 0b00111100};
const byte CHIFFRE_4[] PROGMEM = {0b00000100, 0b00001100, 0b00010100, 0b00100100, 0b01111110, 0b00000100, 0b00000100, 0b00000100};
const byte CHIFFRE_5[] PROGMEM = {0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b00000010, 0b00000010, 0b01000010, 0b00111100};
const byte CHIFFRE_6[] PROGMEM = {0b00111100, 0b01000010, 0b01000000, 0b01111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_7[] PROGMEM = {0b01111110, 0b00000010, 0b00000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000000};
const byte CHIFFRE_8[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_9[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111110, 0b00000010, 0b01000010, 0b00111100};
 
// Tableau des chiffres pour accès rapide
const byte* const CHIFFRES[] PROGMEM = {CHIFFRE_0, CHIFFRE_1, CHIFFRE_2, CHIFFRE_3, CHIFFRE_4, CHIFFRE_5, CHIFFRE_6, CHIFFRE_7, CHIFFRE_8, CHIFFRE_9};

// Fonction d'affichage d'un chiffre sur une matrice
void afficherChiffre(int position, const byte* chiffre);

// Variables globales
bool format24h = true;           // Par défaut, format 24h
bool boutonEtatPrecedent = false; // État précédent du bouton
bool modeAjustement = false; // Indique si on est en mode ajustement
int heuresAjustees = 0;
int minutesAjustees = 0;
int alarmHour = 0;
int alarmMinute = 0;


void afficherChiffre(int position, const byte* chiffre) {
  for (int i = 0; i < 8; i++) {
    matriceLed.setRow(position, i, pgm_read_byte(&(chiffre[i])));  // Charge chaque ligne de la matrice
  }
}

void afficherHeure(int heures, int minutes) {
  afficherChiffre(3, (const byte*)pgm_read_word(&(CHIFFRES[heures / 10])));
  afficherChiffre(2, (const byte*)pgm_read_word(&(CHIFFRES[heures % 10])));
  afficherChiffre(1, (const byte*)pgm_read_word(&(CHIFFRES[minutes / 10])));
  afficherChiffre(0, (const byte*)pgm_read_word(&(CHIFFRES[minutes % 10])));
}

void ajusterHeure() {
  if (digitalRead(boutonHeures)) {
    heuresAjustees = (heuresAjustees + 1) % (format24h ? 24 : 12); // Limite à 23h ou 11h
    if (heuresAjustees == 0 && !format24h) heuresAjustees = 12;    // Minuit devient 12h en 12h
    delay(200); // Anti-rebond
  }
  
  if (digitalRead(boutonMinutes)) {
    minutesAjustees = (minutesAjustees + 1) % 60; // Limite à 59 minutes
    delay(200); // Anti-rebond
  }

  afficherHeure(heuresAjustees, minutesAjustees);
}

void gererBoutonsModeAjustement() {
  if (digitalRead(boutonValider)) {
    if (!modeAjustement) {
      // Activation du mode ajustement
      modeAjustement = true;
      DateTime now = rtc.now();
      heuresAjustees = now.hour();
      minutesAjustees = now.minute();
    } else {
      // Validation et désactivation du mode ajustement
      rtc.adjust(DateTime(2023, 1, 1, heuresAjustees, minutesAjustees, 0)); // Exemple de date arbitraire
      modeAjustement = false;
    }
    delay(500); // Anti-rebond
  }

  if (modeAjustement) {
    ajusterHeure();
  }
}
void ajusterAlarme() {
  static bool enModeAjustementAlarme = false;
  static bool pointAllume = false;
  static int heuresAlarme = alarmHour;
  static int minutesAlarme = alarmMinute;

  if (!enModeAjustementAlarme) {
    enModeAjustementAlarme = true;
    heuresAlarme = alarmHour;
    minutesAlarme = alarmMinute;
  }

  if (digitalRead(boutonHeures)) {
    heuresAlarme = (heuresAlarme + 1) % 24;
    delay(200); // Anti-rebond
  }

  if (digitalRead(boutonMinutes)) {
    minutesAlarme = (minutesAlarme + 1) % 60;
    delay(200); // Anti-rebond
  }

  // Clignotement du séparateur    
  pointAllume = !pointAllume;
  matriceLed.setLed(2, 3, 7, pointAllume);
  afficherHeure(heuresAlarme, minutesAlarme);

  if (digitalRead(boutonValider)) {
    // Validation de l'alarme
    alarmHour = heuresAlarme;
    alarmMinute = minutesAlarme;
    enModeAjustementAlarme = false;
    delay(500); // Anti-rebond
  }
}

// Lissage de la valeur du potentiomètre
int lirePotentiometreStable() {
  int somme = 0;
  // Ajouter la nouvelle valeur dans le tableau
  valeursPotentiometre[indice] = analogRead(potPin);
  indice = (indice + 1) % NOMBRE_LISSAGE;

  // Calculer la moyenne des dernières lectures
  for (int i = 0; i < NOMBRE_LISSAGE; i++) {
    somme += valeursPotentiometre[i];
  }

  return somme / NOMBRE_LISSAGE;  // Retourner la moyenne
}

void displayMenu(int option) {
  display.clearDisplay();
  display.setCursor(0, 0);
  
  const char* menuOptions[] = {"Format de l'heure", "Reglage Alarme", "Option 3", "Option 4"};
  
  for (int i = 0; i < numOptions; i++) {
    display.setTextColor(i == option ? BLACK : WHITE, i == option ? WHITE : BLACK);
    display.setCursor(0, i * 10);
    display.println(menuOptions[i]);
  }
  display.display();
}

void selectFormat() {
  delay(1000);
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Select format:");
  display.setCursor(0, 10);
  display.println("1. 24h");
  display.setCursor(0, 20);
  display.println("2. 12h AM/PM");
  display.display();

  int lastSubOption = 0;
  bool selecting = true;
  while (selecting) {
    // Lire la valeur stable du potentiomètre
    int potValue = lirePotentiometreStable();
    int subOption = (potValue < SEUIL_DE_CHANGEMENT) ? 1 : 2;  // 1 pour 24h, 2 pour 12h

    // Afficher la sélection de manière lisible si l'option a changé
    if (subOption != lastSubOption) {
      lastSubOption = subOption;

      display.setCursor(0, 10);
      display.setTextColor(subOption == 1 ? BLACK : WHITE, subOption == 1 ? WHITE : BLACK);
      display.println("1. 24h");

      display.setCursor(0, 20);
      display.setTextColor(subOption == 2 ? BLACK : WHITE, subOption == 2 ? WHITE : BLACK);
      display.println("2. 12h AM/PM");
      display.display();

      delay(200);  // Attendre un peu avant de redessiner l'écran
    }

    // Confirmer la sélection avec le bouton sur la broche 2
    if (digitalRead(buttonSelectPin) == LOW) {
      selecting = false;
      format24h = (subOption == 1);  // Définir format24h en fonction de l'option sélectionnée
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(format24h ? "Format 24h choisi" : "Format 12h AM/PM choisi");
      display.display();
      delay(2000);  // Attendre 2 secondes pour afficher la confirmation

      // Attendre que le bouton soit relâché
      while (digitalRead(buttonSelectPin) == LOW) {
        delay(10);
      }
    }
  }
}

void modifierHeureSurOLED() {
  int heures = 8; // Heure par défaut
  int minutes = 0; // Minute par défaut
  bool ajustementTermine = false;

  unsigned long lastHeurePress = 0; // Dernier moment où le bouton heures a été pressé
  unsigned long lastMinutePress = 0; // Dernier moment où le bouton minutes a été pressé
  unsigned long lastValidationPress = 0; // Dernier moment où le bouton de validation a été pressé
  unsigned long debounceDelay = 100; // Délais anti-rebond en millisecondes

  display.clearDisplay();
  display.setTextSize(2);

  while (!ajustementTermine) {
    // Affiche l'heure actuelle sur l'écran OLED
    display.clearDisplay();
    display.setCursor(20, 20);
    display.print(heures < 10 ? "0" : "");
    display.print(heures);
    display.print(":");
    display.print(minutes < 10 ? "0" : "");
    display.print(minutes);
    display.display();

    // Vérifie si le bouton des heures est appuyé
    if (digitalRead(boutonHeures) == HIGH && (millis() - lastHeurePress) > debounceDelay) {
      heures = (heures + 1) % 24; // Incrémente les heures (24h max)
      lastHeurePress = millis(); // Met à jour le moment où le bouton a été pressé
    }

    // Vérifie si le bouton des minutes est appuyé
    if (digitalRead(boutonMinutes) == HIGH && (millis() - lastMinutePress) > debounceDelay) {
      minutes = (minutes + 1) % 60; // Incrémente les minutes (59 max)
      lastMinutePress = millis(); // Met à jour le moment où le bouton a été pressé
    }

    // Vérifie si le bouton de validation est appuyé (pin2)
    delay(500);
    if (digitalRead(ok) == LOW && (millis() - lastValidationPress) > debounceDelay) {
      ajustementTermine = true; // Termine l'ajustement lorsque l'utilisateur appuie sur le bouton de validation
      lastValidationPress = millis(); // Met à jour le moment où le bouton a été pressé
    }
    
    // Aucun délai d'attente supplémentaire ici, tout se fait avec millis() pour plus de réactivité.
  }

  // Affichage final de confirmation
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Alarme:");
  display.setCursor(0, 20);
  display.print(heures < 10 ? "0" : "");
  display.print(heures);
  display.print(":");
  display.print(minutes < 10 ? "0" : "");
  display.print(minutes);
  display.display();
  delay(2000); // Affiche la confirmation pendant 2 secondes
  displayMenu(menuOption);
}


void selectOption(int option) {
  if (option == 0) {
    selectFormat();
  } else if (option == 1) { // Gestion de l'option 2
    modifierHeureSurOLED();
    } else {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Option " + String(option + 1) + " choisie");
    display.display();
    delay(2000);
  }
}

void loop() {
  static bool alarmeActivee = false;
  static unsigned long previousMillis = 0;
  const long interval = 1000; // Intervalle de 1 seconde
  static bool pointAllume = false;

  // Si on est en mode ajustement, gérer les boutons
  gererBoutonsModeAjustement();

  if (!modeAjustement) {
    // Récupérer l'heure actuelle
    DateTime now = rtc.now();

    // Afficher l'heure actuelle
    afficherHeure(now.hour(), now.minute());

    // Vérifier si l'heure actuelle correspond à l'heure de l'alarme
    if (now.hour() == alarmHour && now.minute() == alarmMinute && !alarmeActivee) {
      // Activer le buzzer
      digitalWrite(buzzerPin, HIGH);
      delay(1000); // Durée du signal du buzzer
      digitalWrite(buzzerPin, LOW);
      alarmeActivee = true; // Éviter les répétitions d'alarme dans la même minute
    }


    // Réinitialiser l'état de l'alarme à la minute suivante
    if (now.minute() != alarmMinute) {
      alarmeActivee = false;
    }
  }

  // Vérifier si le bouton pour ajuster l'alarme est appuyé
  if (digitalRead(ok) == LOW) { // Bouton appuyé (utilisation du pull-up)
    delay(200); // Anti-rebond
    // Entrer dans le mode d'ajustement de l'alarme
  }

  // Faire clignoter le séparateur toutes les secondes
    pointAllume = !pointAllume;
    matriceLed.setLed(2, 3, 7, pointAllume);

    delay(1000); // Clignotement du séparateur
   int potValue = analogRead(potPin);

  if (abs(potValue - lastPotValue) > threshold) {
    menuOption = map(potValue, 0, 1023, 0, numOptions - 1); 
    lastPotValue = potValue;
    displayMenu(menuOption);
  }

  if (digitalRead(buttonSelectPin) == LOW) {
    selectOption(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonSelectPin) == LOW) {
      delay(10);
    }
  }

  if (digitalRead(buttonBackPin) == LOW) {
    displayMenu(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonBackPin) == LOW) {
      delay(10);
    }
  }

  if (!modeAjustement) {
    static int minutePrecedente = -1;
    static bool pointAllume = false;
    DateTime now = rtc.now();

    int heures = now.hour();
    int minutes = now.minute();
    bool amPm = heures >= 12;

    if (!format24h) {
      if (heures == 0) heures = 12;
      else if (heures > 12) heures -= 12;
    }

    if (minutes != minutePrecedente) {
      minutePrecedente = minutes;
      afficherHeure(heures, minutes);
    }
    //clignotement séparateur
    pointAllume = !pointAllume;
    matriceLed.setLed(2, 3, 7, pointAllume);

    delay(1000);
  }

  // Attendre l'appui sur le bouton de retour pour revenir au menu principal
  if (digitalRead(buttonBackPin) == LOW) {
    displayMenu(menuOption);
    delay(500);

    // Attendre que le bouton soit relâché
    while (digitalRead(buttonBackPin) == LOW) {
      delay(10);
    }
  }
}

void setup() {
  // Initialisation des matrices LED
  for (int i = 0; i < nombreDeMatricesLedRaccordees; i++) {
    matriceLed.shutdown(i, false);     // Réveille la matrice LED
    matriceLed.setIntensity(i, 8);    // Définit l'intensité (0-15)
    matriceLed.clearDisplay(i);       // Efface l'affichage
  }

  Serial.begin(9600);
  Serial.println("Init : 0");
 
  Wire.begin();       // Initialise la communication I2C
  
  Serial.println("Init : 1");

  rtc.begin();       
  rtc.adjust(DateTime(__DATE__, __TIME__));

  Serial.println("Init : 2");

  pinMode(boutonHeures, INPUT);  // Bouton pour ajuster les heures
  pinMode(boutonMinutes, INPUT); // Bouton pour ajuster les minutes
  pinMode(boutonValider, INPUT); // Bouton pour valider les ajustements
  pinMode(buzzerPin, OUTPUT);    // Buzzer

  pinMode(ok, INPUT_PULLUP);     // Bouton pour régler l'alarme
  for (int i = 0; i < nombreDeMatricesLedRaccordees; i++) {
    matriceLed.shutdown(i, false);
    matriceLed.setIntensity(i, 8);
    matriceLed.clearDisplay(i);
  }

  Serial.begin(9600);
  Wire.begin();
  rtc.begin();
  rtc.adjust(DateTime(__DATE__, __TIME__));

  pinMode(buttonSelectPin, INPUT_PULLUP);
  pinMode(buttonBackPin, INPUT_PULLUP);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }

  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  displayMenu(menuOption);

}
