
#include <LedControl.h>
#include <avr/pgmspace.h>
#include <Wire.h>
#include <RTClib.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


// Broches pour l'écran OLED et le potentiomètre
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const int potPin = A0;
const int buttonSelectPin = 2;
const int buttonBackPin = 3;
int menuOption = 0;
const int numOptions = 4;
int lastPotValue = 0;
int threshold = 50;

// Variables pour le lissage du potentiomètre
#define NOMBRE_LISSAGE 10  // Nombre de lectures pour lisser la valeur
#define SEUIL_DE_CHANGEMENT 512  // Seuil de changement de format (modifié selon la plage de potentiomètre)
int valeursPotentiometre[NOMBRE_LISSAGE];  // Tableau pour stocker les dernières valeurs
int indice = 0;  // Indice pour ajouter de nouvelles valeurs
// Définition des broches de raccordement Arduino Nano → Matrice LED pilotée par MAX7219
#define brocheDeSelection               10  // Sortie D10 de l'Arduino (/SS) vers la broche CS de la matrice LED
#define brochePourLesDonnees            11  // Sortie D11 de l'Arduino (MOSI) vers la broche DIN de la matrice LED
#define brochePourLhorloge              13  // Sortie D13 de l'Arduino (SCK) vers la broche CLK de la matrice LED
#define ok              2 
#define boutonHeures   5  // Bouton pour ajuster les heures (D3)
#define boutonMinutes  4  // Bouton pour ajuster les minutes (D4)
#define boutonValider  5  // Bouton pour valider l'heure ajustée (D5)
#define buzzerPin      8  // Buzzer connecté à D8

// Définition des autres constantes
#define nombreDeMatricesLedRaccordees   4   // Nombre total de matrices LED (4 pour HH:MM)

// Instanciation des objets LedControl et RTC
LedControl matriceLed = LedControl(brochePourLesDonnees, brochePourLhorloge, brocheDeSelection, nombreDeMatricesLedRaccordees);
RTC_DS3231 rtc;

// Définition des chiffres en PROGMEM
const byte CHIFFRE_0[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_1[] PROGMEM = {0b00001000, 0b00011000, 0b00101000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00011100};
const byte CHIFFRE_2[] PROGMEM = {0b00111100, 0b01000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000010, 0b01111110};
const byte CHIFFRE_3[] PROGMEM = {0b00111100, 0b01000010, 0b00000110, 0b00011100, 0b00000110, 0b00000010, 0b01000010, 0b00111100};
const byte CHIFFRE_4[] PROGMEM = {0b00000100, 0b00001100, 0b00010100, 0b00100100, 0b01111110, 0b00000100, 0b00000100, 0b00000100};
const byte CHIFFRE_5[] PROGMEM = {0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b00000010, 0b00000010, 0b01000010, 0b00111100};
const byte CHIFFRE_6[] PROGMEM = {0b00111100, 0b01000010, 0b01000000, 0b01111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_7[] PROGMEM = {0b01111110, 0b00000010, 0b00000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000000};
const byte CHIFFRE_8[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111100};
const byte CHIFFRE_9[] PROGMEM = {0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b00111110, 0b00000010, 0b01000010, 0b00111100};
 
// Tableau des chiffres pour accès rapide
const byte* const CHIFFRES[] PROGMEM = {CHIFFRE_0, CHIFFRE_1, CHIFFRE_2, CHIFFRE_3, CHIFFRE_4, CHIFFRE_5, CHIFFRE_6, CHIFFRE_7, CHIFFRE_8, CHIFFRE_9};

// Fonction d'affichage d'un chiffre sur une matrice
void afficherChiffre(int position, const byte* chiffre);

// Variables globales
bool format24h = true;           // Par défaut, format 24h
bool boutonEtatPrecedent = false; // État précédent du bouton
bool modeAjustement = false; // Indique si on est en mode ajustement
int heuresAjustees = 0;
int minutesAjustees = 0;
int alarmHour = 0;
int alarmMinute = 0;


void afficherChiffre(int position, const byte* chiffre) {
  for (int i = 0; i < 8; i++) {
    matriceLed.setRow(position, i, pgm_read_byte(&(chiffre[i])));  // Charge chaque ligne de la matrice
  }
}

void afficherHeure(int heures, int minutes) {
  afficherChiffre(3, (const byte*)pgm_read_word(&(CHIFFRES[heures / 10])));
  afficherChiffre(2, (const byte*)pgm_read_word(&(CHIFFRES[heures % 10])));
  afficherChiffre(1, (const byte*)pgm_read_word(&(CHIFFRES[minutes / 10])));
  afficherChiffre(0, (const byte*)pgm_read_word(&(CHIFFRES[minutes % 10])));
}

void ajusterHeure() {
  if (digitalRead(boutonHeures)) {
    heuresAjustees = (heuresAjustees + 1) % (format24h ? 24 : 12); // Limite à 23h ou 11h
    if (heuresAjustees == 0 && !format24h) heuresAjustees = 12;    // Minuit devient 12h en 12h
    delay(200); // Anti-rebond
  }
  
  if (digitalRead(boutonMinutes)) {
    minutesAjustees = (minutesAjustees + 1) % 60; // Limite à 59 minutes
    delay(200); // Anti-rebond
  }

  afficherHeure(heuresAjustees, minutesAjustees);
}

// Ajouter une variable pour suivre l'état du mode d'ajustement
bool modeAjustementHeure = false;

// Modifier la fonction de gestion du mode d'ajustement
void gererBoutonAjustementHeure() {
  static bool etatBoutonPrecedent = HIGH; // État précédent du bouton
  bool etatBoutonActuel = digitalRead(buttonBackPin); // Lire l'état du bouton (pin 3)

  // Détecter un changement d'état (appui sur le bouton)
  if (etatBoutonActuel == LOW && etatBoutonPrecedent == HIGH) {
    // Inverser le mode d'ajustement
    modeAjustementHeure = !modeAjustementHeure;

    if (modeAjustementHeure) {
      // Entrer en mode d'ajustement : initialiser les heures et minutes actuelles
      DateTime now = rtc.now();
      heuresAjustees = now.hour();
      minutesAjustees = now.minute();
    } else {
      // Sortir du mode d'ajustement : valider les nouvelles heures et minutes
      rtc.adjust(DateTime(2023, 1, 1, heuresAjustees, minutesAjustees, 0)); // Exemple de date arbitraire
    }

    delay(500); // Anti-rebond
  }

  etatBoutonPrecedent = etatBoutonActuel;

  // Si on est en mode d'ajustement, permettre de modifier les heures et minutes
  if (modeAjustementHeure) {
    ajusterHeure();
  }
}

void ajusterAlarme() {
  static bool enModeAjustementAlarme = false;
  static bool pointAllume = false;
  static int heuresAlarme = alarmHour;
  static int minutesAlarme = alarmMinute;

  if (!enModeAjustementAlarme) {
    enModeAjustementAlarme = true;
    heuresAlarme = alarmHour;
    minutesAlarme = alarmMinute;
  }

  if (digitalRead(boutonHeures)) {
    heuresAlarme = (heuresAlarme + 1) % 24;
    delay(200); // Anti-rebond
  }

  if (digitalRead(boutonMinutes)) {
    minutesAlarme = (minutesAlarme + 1) % 60;
    delay(200); // Anti-rebond
  }

  // Clignotement du séparateur    
  pointAllume = !pointAllume;
  matriceLed.setLed(2, 3, 7, pointAllume);
  afficherHeure(heuresAlarme, minutesAlarme);

  if (digitalRead(boutonValider)) {
    // Validation de l'alarme
    alarmHour = heuresAlarme;
    alarmMinute = minutesAlarme;
    enModeAjustementAlarme = false;
    delay(500); // Anti-rebond
  }
}

// Lissage de la valeur du potentiomètre
int lirePotentiometreStable() {
  int somme = 0;
  // Ajouter la nouvelle valeur dans le tableau
  valeursPotentiometre[indice] = analogRead(potPin);
  indice = (indice + 1) % NOMBRE_LISSAGE;

  // Calculer la moyenne des dernières lectures
  for (int i = 0; i < NOMBRE_LISSAGE; i++) {
    somme += valeursPotentiometre[i];
  }

  return somme / NOMBRE_LISSAGE;  // Retourner la moyenne
}

void displayMenu(int option) {
  display.clearDisplay();
  display.setCursor(0, 0);
  
  const char* menuOptions[] = {"Format de l'heure", "Option 2", "Option 3", "Option 4"};
  
  for (int i = 0; i < numOptions; i++) {
    display.setTextColor(i == option ? BLACK : WHITE, i == option ? WHITE : BLACK);
    display.setCursor(0, i * 10);
    display.println(menuOptions[i]);
  }
  display.display();
}

void selectFormat() {
  delay(1000);
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Select format:");
  display.setCursor(0, 10);
  display.println("1. 24h");
  display.setCursor(0, 20);
  display.println("2. 12h AM/PM");
  display.display();

  int lastSubOption = 0;
  bool selecting = true;
  while (selecting) {
    // Lire la valeur stable du potentiomètre
    int potValue = lirePotentiometreStable();
    int subOption = (potValue < SEUIL_DE_CHANGEMENT) ? 1 : 2;  // 1 pour 24h, 2 pour 12h

    // Afficher la sélection de manière lisible si l'option a changé
    if (subOption != lastSubOption) {
      lastSubOption = subOption;

      display.setCursor(0, 10);
      display.setTextColor(subOption == 1 ? BLACK : WHITE, subOption == 1 ? WHITE : BLACK);
      display.println("1. 24h");

      display.setCursor(0, 20);
      display.setTextColor(subOption == 2 ? BLACK : WHITE, subOption == 2 ? WHITE : BLACK);
      display.println("2. 12h AM/PM");
      display.display();

      delay(200);  // Attendre un peu avant de redessiner l'écran
    }

    // Confirmer la sélection avec le bouton sur la broche 2
    if (digitalRead(buttonSelectPin) == LOW) {
      selecting = false;
      format24h = (subOption == 1);  // Définir format24h en fonction de l'option sélectionnée
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(format24h ? "Format 24h choisi" : "Format 12h AM/PM choisi");
      display.display();
      delay(2000);  // Attendre 2 secondes pour afficher la confirmation
      displayMenu(menuOption);
      // Attendre que le bouton soit relâché
      while (digitalRead(buttonSelectPin) == LOW) {
        delay(10);
      }
    }
  }
}

void selectOption(int option) {
  if (option == 0) {
    selectFormat();
  } else {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Option " + String(option + 1) + " choisie");
    display.display();
    delay(2000);
  }
}
void loop() {
  // Gérer le mode d'ajustement de l'heure via le bouton en pin 3
  static bool modeAjustementHeure = false;
  static bool etatBoutonPrecedent = HIGH;
  bool etatBoutonActuel = digitalRead(buttonBackPin); // Lire l'état du bouton (pin 3)

  // Détecter un changement d'état pour activer/désactiver le mode d'ajustement
  if (etatBoutonActuel == LOW && etatBoutonPrecedent == HIGH) {
    modeAjustementHeure = !modeAjustementHeure;

    if (modeAjustementHeure) {
      // Entrer en mode d'ajustement : initialiser heures/minutes actuelles
      DateTime now = rtc.now();
      heuresAjustees = now.hour();
      minutesAjustees = now.minute();
    } else {
      // Sortir du mode d'ajustement : valider l'heure ajustée
      rtc.adjust(DateTime(2023, 1, 1, heuresAjustees, minutesAjustees, 0)); // Valider l'heure ajustée
    }

    delay(500); // Anti-rebond
  }

  etatBoutonPrecedent = etatBoutonActuel;

  // Si on est en mode d'ajustement
  if (modeAjustementHeure) {
    // Permettre de modifier les heures et minutes
    static bool etatHeurePrecedent = HIGH, etatMinutePrecedent = HIGH;

    // Gestion du bouton des heures (pin 5)
    bool etatHeureActuel = digitalRead(boutonHeures);
    if (etatHeureActuel == LOW && etatHeurePrecedent == HIGH) {
      heuresAjustees = (heuresAjustees + 1) % 24; // Incrémenter l'heure, modulo 24
      delay(200); // Anti-rebond
    }
    etatHeurePrecedent = etatHeureActuel;

    // Gestion du bouton des minutes (pin 4)
    bool etatMinuteActuel = digitalRead(boutonMinutes);
    if (etatMinuteActuel == LOW && etatMinutePrecedent == HIGH) {
      minutesAjustees = (minutesAjustees + 1) % 60; // Incrémenter les minutes, modulo 60
      delay(200); // Anti-rebond
    }
    etatMinutePrecedent = etatMinuteActuel;

    // Afficher l'heure ajustée en temps réel sur la matrice LED
    afficherHeure(heuresAjustees, minutesAjustees);
  } else {
    // Si on n'est pas en mode d'ajustement, afficher l'heure actuelle normalement
    DateTime now = rtc.now();
    afficherHeure(now.hour(), now.minute());

    // Vérifier si c'est l'heure de l'alarme
    static bool alarmeActivee = false;
    if (now.hour() == alarmHour && now.minute() == alarmMinute && !alarmeActivee) {
      digitalWrite(buzzerPin, HIGH); // Activer le buzzer
      delay(1000);
      digitalWrite(buzzerPin, LOW);
      alarmeActivee = true;
    }

    if (digitalRead(buttonSelectPin) == LOW) 
    selectOption(menuOption);
    delay(500);

    // Réinitialiser l'alarme si on change de minute
    if (now.minute() != alarmMinute) {
      alarmeActivee = false;
    }

    // Clignoter le séparateur ":" chaque seconde
    static unsigned long dernierMillis = 0;
    if (millis() - dernierMillis >= 1000) {
      dernierMillis = millis();
      static bool pointAllume = false;
      pointAllume = !pointAllume;
      matriceLed.setLed(2, 3, 7, pointAllume); // Basculer l'état du séparateur
    }
  }
}

void setup() {
  // Initialisation des matrices LED
  for (int i = 0; i < nombreDeMatricesLedRaccordees; i++) {
    matriceLed.shutdown(i, false);     // Réveille la matrice LED
    matriceLed.setIntensity(i, 8);    // Définit l'intensité (0-15)
    matriceLed.clearDisplay(i);       // Efface l'affichage
  }

  Serial.begin(9600);
  Serial.println("Init : 0");
 
  Wire.begin();       // Initialise la communication I2C
  
  Serial.println("Init : 1");

  rtc.begin();       
  rtc.adjust(DateTime(__DATE__, __TIME__));

  Serial.println("Init : 2");

  pinMode(boutonHeures, INPUT);  // Bouton pour ajuster les heures
  pinMode(boutonMinutes, INPUT); // Bouton pour ajuster les minutes
  pinMode(boutonValider, INPUT); // Bouton pour valider les ajustements
  pinMode(buzzerPin, OUTPUT);    // Buzzer

  pinMode(ok, INPUT_PULLUP);     // Bouton pour régler l'alarme
  for (int i = 0; i < nombreDeMatricesLedRaccordees; i++) {
    matriceLed.shutdown(i, false);
    matriceLed.setIntensity(i, 8);
    matriceLed.clearDisplay(i);
  }

  Serial.begin(9600);
  Wire.begin();
  rtc.begin();
  rtc.adjust(DateTime(__DATE__, __TIME__));

  pinMode(buttonSelectPin, INPUT_PULLUP);
  pinMode(buttonBackPin, INPUT_PULLUP);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }

  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  displayMenu(menuOption);

}

